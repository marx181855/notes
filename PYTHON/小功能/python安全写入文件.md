# 1 一般的写入文件

```python
f = open ('demo.txt','w')
f.write('123')
f.close
```

open() 方法用于打开一个文件，并返回文件对象，用文件对象调用写入方法，然后关闭文件对象。

注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法，因为文件对象不关闭会占用系统资源。

由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：

```python
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```
# 2 使用with关键词
但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：

这和上面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。
```python
with open ('demo.txt','w') as f:
    f.write('123')
```
# 3 安全写入文件
```python
import os

with open("demo.txt", "w") as f:
    f.write("123")
    f.flush()
    os.fsync(f.fileno())
```
## 通常涉及两个级别的缓冲：

- 内部缓冲器
- 操作系统缓冲区

内部缓冲区是由您针对其进行编程的运行时/库/语言创建的缓冲区，其目的是通过避免每次写入都调用系统来加快处理速度。取而代之的是，当您写入文件对象时，您将写入其缓冲区，并且只要缓冲区被填满，就会使用系统调用将数据写入实际文件。

但是，由于操作系统缓冲区的原因，这可能并不意味着数据已写入disk。这可能仅意味着将数据从运行时维护的缓冲区复制到操作系统维护的缓冲区。

如果您写了一些东西，并且它最终在缓冲区中（仅），并且切断了计算机的电源，则当计算机关闭时，该数据将不在磁盘上。

因此，为了帮助您在各自的对象上使用flush和fsync方法。

第一个flush会刷新程序缓冲区，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。通常，这意味着数据将从程序缓冲区复制到操作系统缓冲区。

为此，您需要调用os.fsync确保所有操作系统缓冲区与它们所使用的存储设备同步的方法，换句话说，该方法会将数据从操作系统缓冲区复制到磁盘。
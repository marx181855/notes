# 1、同步、异步、阻塞、非阻塞

 

## 1.1 、从单进程的的维度来看

 

### 1.1.1、同步与异步

同步与异步针对的是**函数/任务的调用方式**，同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)。
所谓同步，就是当一个进程在发起一个函数（任务）调用时，一直等到函数（任务）调用返回。在没有得到结果之前，该函数（任务）调用就不返回。但是一旦调用返回，就得到返回值了。

而异步情况下是当一个进程发起一个函数（任务）调用的时候，不会等函数返回，而是继续往下执行其他程序，函数返回的时候通过状态、通知、事件等方式通知进程任务完成。

 

### 1.1.2、阻塞与非阻塞

阻塞与非阻塞针对的是**进程或线程**，阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**。

阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作），函数只有在得到结果之后才会将阻塞的线程激活。

有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。

非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前也会立刻返回，同时该函数（任务）调用不会阻塞当前线程。

 

## 1.2、从多进程通信层面

 

### 1.2.1、第一种说法

阻塞/非阻塞， 同步/异步基本是**同义词**， 但是需要注意区分讨论的对象是**发送方还是接收方**。

进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是**阻塞的**或**非阻塞的** – 也被称为**同步**或**异步**的：

- 阻塞式发送（blocking send）. 发送方进程会被一直阻塞， 直到消息被接受方进程收到。
- 非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。
- 阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。
- 非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。

发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。

 

### 1.2.2、第二种说法

阻塞，非阻塞是从调用者角度来讲的，调用后是否可以去干其他工作。同步，异步是从被调用者来讲，调用结束后是否主动返回结果。 他们共4种组合，分别是阻塞同步，阻塞异步，非阻塞同步，非阻塞异步。

 

# 2、并发、并行、串行

 无论是并行还是并发，在用户看来都是'同时'运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务。

## 2.1、串行

一个CPU核心在一个时间段里，只能处理完一个任务才能接着下一个任务。

## 2.2、并行

多个CPU核心在一个时间段里，同时处理任务(这里是没有说明是用并发还是串行)。

## 2.3、并发

一个cpu核心利用多道技术，在一个时间段里，将每个任务运行几十或几百毫秒，然后就切换另外一个任务，虽然在同一时刻，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并行。

 ![](./images/并发、并行、串行、同步、异步、阻塞、非阻塞-1.png)

 

 

 

------

 

**参考**：

https://www.zhihu.com/question/19732473

https://www.cnblogs.com/linhaifeng/articles/7430066.html#_label4

https://blog.csdn.net/huangqiang1363/article/details/79508852
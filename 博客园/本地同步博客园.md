一直以来，写博客有个痛点，单单在博客平台写文章吧，担心博客丢失或者被删除，如果每次发布后再下载至本地存档，这个过程又过于繁杂。在本地写博客吧，无法便捷的分享和阅读，所以打算写一个本地博客同步的小程序，每次在`Typora`用`markdown`写完博客，执行程序自动将本地的博客同步到博客园。

那么如何来实现这个程序呢？一开始是想通过python抓包的形式来发送请求，但在实现的过程中，发现极其麻烦和难度较大，故而放弃。

在搜索引擎的苦苦搜索中，发现找到了一个名叫MetaWeBlog的API。

# 1、metaWebBlog 概述

> MetaWeblog API（MWA）是一个Blog程序接口标准。通过MetaWeblog API，博客平台可以对外公布blog提供的服务，从而允许外面的程序新建，编辑，删除，发布bolg。

MetaWeblog 使用 xml-RPC 作为通讯协议。

> XML-RPC是一个远程过程调用（远端程序呼叫）（remote procedure call，RPC)的分布式计算协议，通过XML将调用函数封装，并使用HTTP协议作为传送机制。一个XML-RPC消息就是一个请求体为xml的http-post请求，被调用的方法在服务器端执行并将执行结果以xml格式编码后返回。

简单理解就是：在 HTTP请求 中，发送 xml 格式描述的“调用指令”，如果调用成功，会收到 xml格式描述的“执行结果”。

# 2、博客园文章相关接口：


- blogger.deletePost ——删除博客
- blogger.getUsersBlogs——获取用户博客信息
- metaWeblog.editPost——编辑博客
- metaWeblog.getCategories——获取分类
- metaWeblog.getPost——获取博客
- metaWeblog.getRecentPosts——获取最近的博客
- metaWeblog.newMediaObject——上传图片
- metaWeblog.newPost——添加博客
- wp.newCategory——添加新分类

## 2.1 接口说明

在博客园管理后台设置页面选项页的地方往下拉可以找到MetaBlog的url，点进去就看API接口的详细说明，类似这样：

`https://rpc.cnblogs.com/metaweblog/{userName}`
上面的 {userName} 替换成实际的用户名。

下文仅说明“请求的接口和参数”，响应内容在发送成功后一看便知。

## 2.2 发送方式

HTTP 请求
POST方式到： https://rpc.cnblogs.com/metaweblog/{userName}
请求中的内容是HTML格式，描述了调用参数

##    2.3 接口协议

### 2.3.1 获取用户博客信息
- 功能：获取用户博客信息
- 方法名: blogger.getUsersBlogs
- 参数：见下文代码
示例：

```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>blogger.getUsersBlogs</methodName>
  <params>
    <param>
        <value><string></string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
  </params>
</methodCall>
```
### 2.3.2 获取最近的文章
- 功能：获取最近的文章
- 方法名: metaWeblog.getRecentPosts
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>metaWeblog.getRecentPosts</methodName>
  <params>
    <param>
        <value><string>000000</string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>

    <param>
        <value><i4>1</i4></value>
    </param>
  </params>
</methodCall>
```
### 2.3.3 获取文章内容
- 功能：获取文章内容
- 方法名: metaWeblog.getPost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
    <methodCall>
      <methodName>metaWeblog.getPost</methodName>
      <params>
        <param>
            <value><string>{postid}</string></value>
        </param>
        <param>
            <value><string>{userName}</string></value>
        </param>
        <param>
            <value><string>{password}</string></value>
        </param>
      </params>
</methodCall>
```
### 2.3.4 添加文章
- 功能：添加文章
- 方法名: metaWeblog.newPost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>metaWeblog.newPost</methodName>
  <params>
    <param>
        <value><string></string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
    <param>
         <value>
                <struct>
                    <member>
                        <name>description</name>
                        <value>
                            <string>博客测试内容</string>
                        </value>
                    </member>
                    <member>
                        <name>title</name>
                        <value>
                            <string>标题测试内容</string>
                        </value>
                    </member>
                    <member>
                        <name>categories</name>
                        <value>
                            <array>
                                <data>
                                    <value>
                                        <string>[Markdown]</string>
                                    </value>
                                </data>
                            </array>
                        </value>
                    </member>
                </struct>
            </value>
    </param>
    <param>
        <value><boolean>0</boolean></value>
    </param>
  </params>
</methodCall>
```
### 2.3.5 编辑文章
- 功能：编辑文章
- 方法名: metaWeblog.editPost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>metaWeblog.editPost</methodName>
  <params>
    <param>
        <value><string>{postid}</string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
    <param>
         <value>
                <struct>
                    <member>
                        <name>description</name>
                        <value>
                            <string>博客测试内容222</string>
                        </value>
                    </member>
                    <member>
                        <name>title</name>
                        <value>
                            <string>标题测试内容222</string>
                        </value>
                    </member>
                    <member>
                        <name>categories</name>
                        <value>
                            <array>
                                <data>
                                    <value>
                                        <string>[Markdown]</string>
                                    </value>
                                </data>
                            </array>
                        </value>
                    </member>
                </struct>
            </value>
    </param>
    <param>
        <value><boolean>0</boolean></value>
    </param>
  </params>
</methodCall>
```
### 2.3.6 删除文章
- 功能：删除文章
- 方法名: blogger.deletePost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>blogger.deletePost</methodName>
  <params>
    <param>
        <value><string></string></value>
    </param>
    <param>
        <value><string>{postid}</string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
    <param>
        <value><boolean>0</boolean></value>
    </param>
  </params>
</methodCall>
```
# 3、python3使用MetaWeBlog接口



python使用`xmlrpc.client模块来调用`MetaWeBlog接口的api，这个模块支持编写 XML-RPC 客户端代码；它处理了所有在符合Python对象和XML之间进行翻译的细节。

- Python3内置的xmlrpc.client模块文档：https://docs.python.org/3/library/xmlrpc.client.html

首先来看blogger.getUsersBlogs这个接口，这个接口需要三个参数，appKey、username和password，经过试验，key可以为空，username和password分别是登录博客园的用户名和密码。接口调用的Python代码很简单，首先通过接口URL获取一个ServerProxy对象，然后在该对象上执行方法即可，如下所示：

```python
import xmlrpc.client

# 其中，接口URL就是MetaWeblog的URL。
bp = xmlrpc.client.ServerProxy(接口URL)
print(bp.blogger.getUsersBlogs('', 用户名, 密码))
'''
类似的调用其他的接口
print(bp.blogger.deletePost())
print(bp.metaWeblog.editPost())
print(bp.metaWeblog.getCategories())
print(bp.metaWeblog.getPost())
print(bp.metaWeblog.getRecentPosts())
print(bp.metaWeblog.newMediaObject())
print(bp.metaWeblog.newPost())
print(bp.wp.newCategory())
调用接口方法需要的参数需要自己点击MetaWeBlog的url去查看
'''

```

# 4、编写的本地博客同步程序
```python
import requests
import xmlrpc.client
import os
import time
import re
import json
import logging
import win32con, win32api #第三方库

"""
需要用到metaWeBlog接口的有以下几个：
blogger.deletePost
metaWeblog.editPost
metaWeblog.getRecentPosts
metaWeblog.newPost
metaWeblog.newMediaObject

"""

metaWeblogUrl = ''# 填入自己的MetaWeBlog的url
username = ''  # 填入自己登录博客园的账号
passwd = '' # 填入自己登录博客园的密码
localBlogPath = r''# 填入自己在本地的博客文件夹目录

def getblogInfoRecord():
    with open('blogInfoRecord.json','a+',encoding='utf-8') as f:
        f.seek(0)
        if f.read() == '':
            return {}
        else:
            f.seek(0)
            return json.load(f)

def setblogInfoRecord():
    with open('blogInfoRecord.json','w',encoding='utf-8') as f:
        json.dump(blogInfoRecord,f,ensure_ascii=False)

def hiddenImagesFolder():
    imagesPathList = []
    for root, dirs, files in os.walk(localBlogPath, True):
        if dirs.count('images'):
            imagesPathList.append(root)
            
    for path in imagesPathList:
        os.chdir(path)
        win32api.SetFileAttributes(r'.\images', win32con.FILE_ATTRIBUTE_HIDDEN)

def uploadImage(filename):
    fileData = {"type":'image/png',"name":'1.png',}
    with open(filename,'rb') as f:
        bits = xmlrpc.client.Binary(f.read())
        fileData['bits'] = bits
    r = blogProxy.metaWeblog.newMediaObject('',username,passwd,fileData)
    return r['url']

def searchBlog(keyword):
    for blog in blogList:
        if blog['title'] == keyword:
            blogInfo = {
                'title':blog['title'],
                'postid':blog['postid'],
                'url':blog['permalink'],
                'content':blog['description'],
                'publishDate':blog['dateCreated']
                }
            return blogInfo
    return False

def handlerContent(filename):
    '''
    用来处理本地博客的图片问题，将图片上传，并且替换图片路径,返回博客内容,
    return string content

    '''
    RelativePathPattern = '\./images/.+?\.png'
    namePattern = '\./images/(.+?\.png)'
    with open(filename,'r',encoding='utf-8') as f:
        content = f.read()
        imageRelativePathList = re.findall(RelativePathPattern,content)
        imageNameList = re.findall(namePattern,content)
        imageAbsolutePathList = [f'{os.path.dirname(filename)}\images\{name}' for name in imageNameList]
        imageUrlList = []
        for imageAbsolutePath in imageAbsolutePathList:
            if os.path.exists(imageAbsolutePath):
                imageUrlList.append(uploadImage(imageAbsolutePath) )
        if len(imageUrlList) != 0:
            for num in range(len(imageRelativePathList)):
                content = content.replace(imageRelativePathList[num],imageUrlList[num])
            return content
        return content

def postBlog(filename): 
    title = os.path.basename(filename.replace('.md',''))
    response = searchBlog(title)
    # 判断是否发布过
    if response:
        logging.info(f'“{filename}” 这篇博客已经发布过了！\n')
        blogInfo = {
        'title':response['title'],
        'url':response['url'],
        'postid':response['postid']
        }
        if title not in blogInfoRecord or os.path.getmtime(filename) != blogInfoRecord[title]:
            logging.info(f'“{filename}”编辑过了！\n')
            with open(filename,'r',encoding='utf-8') as f:
                fileContent = handlerContent(filename)
            postData ={
                    'title':title,
                    'description':fileContent,
                    'categories':['[Markdown]']
                }
            postid = response['postid']
            r = blogProxy.metaWeblog.editPost(postid, username, passwd,postData, True)
            if r:
                logging.info(f'“{filename}”更新成功.....\n')
                time.sleep(1)
                blogInfoRecord[title] = os.path.getmtime(filename)
                return blogInfo
        else:
            logging.info(f'“{filename}”没编辑过...\n')
            return blogInfo
    else:
        logging.info(f'“{filename}”未发布')
        with open(filename,'r',encoding='utf-8') as f:
            fileContent = handlerContent(filename)
        postData ={
                'title':title,
                'description':fileContent,
                'categories':['[Markdown]']
            }
        postid = blogProxy.metaWeblog.newPost('', username, passwd,postData, True)
        if postid:
                logging.info(f'“{filename}”发布成功！\n')
                blogInfoRecord[title] = os.path.getmtime(filename)
                blogInfo = {
                'title':title,
                'postid':postid,
                'url':f"www.cnblogs.com/NEGAN-H/p/{postid}.html"
                }
                return blogInfo

def getBlogIndex():
    blogIndex = ''
    for root, dirs, files in os.walk(localBlogPath, True):
        # 过滤没用的root目录
        if(root.count('.git') or (root.count('images')) or 
            root == localBlogPath):
            continue
        # 删掉顶级分类前面的文件夹路径
        folderName = root.replace(localBlogPath+'\\','')
        # 文件夹分类加标题等级
        if (len(folderName.split('\\')) ==1 ):
            blogIndex += f'{1*"#"} {folderName} \n'
        if (len(folderName.split('\\')) ==2 ):
            blogIndex += f'{2*"#"} {folderName} \n'
        if (len(folderName.split('\\')) ==3 ):
            blogIndex += f'{3*"#"} {folderName} \n'
        if (len(folderName.split('\\')) ==4 ):
            blogIndex += f'{4*"#"} {folderName} \n'
        if (len(folderName.split('\\')) ==5 ):
            blogIndex += f'{5*"#"} {folderName} \n'
        if (len(folderName.split('\\')) ==5 ):
            blogIndex += f'{6*"#"} {folderName} \n'
        for fileBaseName in files:
            filename = f'{root}\{fileBaseName}'
            r = postBlog(filename)
            blogIndex += f"[{r['title']}]({r['url']})\n"

    postData = {
        'title':'博客目录索引',
        'description':blogIndex,
        'categories':['[Markdown]']
    }
    return postData

def setBlogIndex():
    postData = getBlogIndex()
    if searchBlog('博客目录索引'):
        r = blogProxy.metaWeblog.editPost(searchBlog('博客目录索引')['postid'], username, passwd,postData,True)
        if r:
            logging.info('博客目录索引完成了\n')
    else:
        r = response = blogProxy.metaWeblog.newPost('', username, passwd,postData, True)
        if r:
            logging.info(f'博客目录索引完成了\n')

def deleteBlogs():
    localBlogTitleList = []
    for root, dirs, files in os.walk(localBlogPath, True):
        # 过滤没用的root目录
        if(root.count('.git') or (root.count('images')) or 
            root == localBlogPath):
            continue
        for i in files:
            localBlogTitleList.append(i.replace('.md',''))
    cloudBlogTitleList = [blog['title'] for blog in blogList]
    deleteBlogTitleList = []
    for i in cloudBlogTitleList:
        if i == '博客目录索引':
            continue
        if i not in localBlogTitleList:
            deleteBlogTitleList.append(i)
    if len(deleteBlogTitleList) == 0:
        return ''
    for title in deleteBlogTitleList:
        for blog in blogList:
            if title == blog['title']:
                try:
                    r = blogProxy.blogger.deletePost('',blog['postid'],username,passwd,True)
                    if r:
                        logging.info(f'博客“{title}”删除成功！\n')
                        time.sleep(1)
                except xmlrpc.client.Fault as err:
                    if err.faultString == '! can not be deleted！':
                        logging.error(f'博客“{title}”无法删除，需手动删除！\n')
        if title in blogInfoRecord:
            del title

if __name__ == '__main__':
    try:
        # 配置loggin，用于记录日志
        logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
        filename='blogSync.log', encoding='utf-8', level=logging.DEBUG)
        # 获取metaWeblog对象，用于发送请求
        blogProxy = xmlrpc.client.ServerProxy(metaWeblogUrl)
        # 获取全部博客，用于博客搜索
        blogList = blogProxy.metaWeblog.getRecentPosts('',username,passwd,99999)
        # 获取博客信息json，用于判断是否需要更新 
        blogInfoRecord = getblogInfoRecord()
        setBlogIndex()
        deleteBlogs()
        setblogInfoRecord()
        # 这个必须放最后面，否则会影响blogInfoRecord.json的生成路径
        hiddenImagesFolder()
        logging.info('博客同步成功！！！')
    except xmlrpc.client.Fault as err:
        if(err.faultString == '! User does not exist') or (err.faultString == 
        'User does not exist'):
            logging.error('IP被拉黑了！！！')
        else:
            logging.error(err.faultString)



```



-----

参考：
https://www.cnblogs.com/nickchen121/p/11132957.html
https://www.cnblogs.com/xupccc/p/9565337.html
https://my.oschina.net/u/4318872/blog/4255010
https://blog.csdn.net/vir56k/article/details/105136435
https://zhuanlan.zhihu.com/p/73564778
https://blog.csdn.net/shajunxing/article/details/79553472
https://docs.python.org/3/library/xmlrpc.client.html
https://blog.csdn.net/weixin_30645617/article/details/97408199
https://blog.csdn.net/phphot/article/details/1863764
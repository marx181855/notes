一直以来，写博客有个痛点，单单在博客平台写文章吧，担心博客丢失或者被删除，如果每次发布后再下载至本地存档，这个过程又过于繁杂。在本地写博客吧，无法便捷的分享和阅读，所以打算写一个本地博客同步的小程序，每次在`Typora`用`markdown`写完博客，执行程序自动将本地的博客同步到博客园。

那么如何来实现这个程序呢？一开始是想通过python抓包的形式来发送请求，但在实现的过程中，发现极其麻烦和难度较大，故而放弃。

在搜索引擎的苦苦搜索中，发现找到了一个名叫MetaWeBlog的API。

# 1、metaWebBlog 概述

> MetaWeblog API（MWA）是一个Blog程序接口标准。通过MetaWeblog API，博客平台可以对外公布blog提供的服务，从而允许外面的程序新建，编辑，删除，发布bolg。

MetaWeblog 使用 xml-RPC 作为通讯协议。

> XML-RPC是一个远程过程调用（远端程序呼叫）（remote procedure call，RPC)的分布式计算协议，通过XML将调用函数封装，并使用HTTP协议作为传送机制。一个XML-RPC消息就是一个请求体为xml的http-post请求，被调用的方法在服务器端执行并将执行结果以xml格式编码后返回。

简单理解就是：在 HTTP请求 中，发送 xml 格式描述的“调用指令”，如果调用成功，会收到 xml格式描述的“执行结果”。

# 2、博客园文章相关接口：


- blogger.deletePost ——删除博客
- blogger.getUsersBlogs——获取用户博客信息
- metaWeblog.editPost——编辑博客
- metaWeblog.getCategories——获取分类
- metaWeblog.getPost——获取博客
- metaWeblog.getRecentPosts——获取最近的博客
- metaWeblog.newMediaObject——上传图片
- metaWeblog.newPost——添加博客
- wp.newCategory——添加新分类

## 2.1 接口说明

在博客园管理后台设置页面选项页的地方往下拉可以找到MetaBlog的url，点进去就看API接口的详细说明，类似这样：

`https://rpc.cnblogs.com/metaweblog/{userName}`
上面的 {userName} 替换成实际的用户名。

下文仅说明“请求的接口和参数”，响应内容在发送成功后一看便知。

## 2.2 发送方式

HTTP 请求
POST方式到： https://rpc.cnblogs.com/metaweblog/{userName}
请求中的内容是HTML格式，描述了调用参数

##    2.3 接口协议

### 2.3.1 获取用户博客信息
- 功能：获取用户博客信息
- 方法名: blogger.getUsersBlogs
- 参数：见下文代码
示例：

```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>blogger.getUsersBlogs</methodName>
  <params>
    <param>
        <value><string></string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
  </params>
</methodCall>
```
### 2.3.2 获取最近的文章
- 功能：获取最近的文章
- 方法名: metaWeblog.getRecentPosts
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>metaWeblog.getRecentPosts</methodName>
  <params>
    <param>
        <value><string>000000</string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>

    <param>
        <value><i4>1</i4></value>
    </param>
  </params>
</methodCall>
```
### 2.3.3 获取文章内容
- 功能：获取文章内容
- 方法名: metaWeblog.getPost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
    <methodCall>
      <methodName>metaWeblog.getPost</methodName>
      <params>
        <param>
            <value><string>{postid}</string></value>
        </param>
        <param>
            <value><string>{userName}</string></value>
        </param>
        <param>
            <value><string>{password}</string></value>
        </param>
      </params>
</methodCall>
```
### 2.3.4 添加文章
- 功能：添加文章
- 方法名: metaWeblog.newPost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>metaWeblog.newPost</methodName>
  <params>
    <param>
        <value><string></string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
    <param>
         <value>
                <struct>
                    <member>
                        <name>description</name>
                        <value>
                            <string>博客测试内容</string>
                        </value>
                    </member>
                    <member>
                        <name>title</name>
                        <value>
                            <string>标题测试内容</string>
                        </value>
                    </member>
                    <member>
                        <name>categories</name>
                        <value>
                            <array>
                                <data>
                                    <value>
                                        <string>[Markdown]</string>
                                    </value>
                                </data>
                            </array>
                        </value>
                    </member>
                </struct>
            </value>
    </param>
    <param>
        <value><boolean>0</boolean></value>
    </param>
  </params>
</methodCall>
```
### 2.3.5 编辑文章
- 功能：编辑文章
- 方法名: metaWeblog.editPost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>metaWeblog.editPost</methodName>
  <params>
    <param>
        <value><string>{postid}</string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
    <param>
         <value>
                <struct>
                    <member>
                        <name>description</name>
                        <value>
                            <string>博客测试内容222</string>
                        </value>
                    </member>
                    <member>
                        <name>title</name>
                        <value>
                            <string>标题测试内容222</string>
                        </value>
                    </member>
                    <member>
                        <name>categories</name>
                        <value>
                            <array>
                                <data>
                                    <value>
                                        <string>[Markdown]</string>
                                    </value>
                                </data>
                            </array>
                        </value>
                    </member>
                </struct>
            </value>
    </param>
    <param>
        <value><boolean>0</boolean></value>
    </param>
  </params>
</methodCall>
```
### 2.3.6 删除文章
- 功能：删除文章
- 方法名: blogger.deletePost
- 参数：见下文代码
```xml
<?xml version="1.0"?>
<methodCall>
  <methodName>blogger.deletePost</methodName>
  <params>
    <param>
        <value><string></string></value>
    </param>
    <param>
        <value><string>{postid}</string></value>
    </param>
    <param>
        <value><string>{userName}</string></value>
    </param>
    <param>
        <value><string>{password}</string></value>
    </param>
    <param>
        <value><boolean>0</boolean></value>
    </param>
  </params>
</methodCall>
```
# 3、python3使用MetaWeBlog接口



python使用`xmlrpc.client模块来调用`MetaWeBlog接口的api，这个模块支持编写 XML-RPC 客户端代码；它处理了所有在符合Python对象和XML之间进行翻译的细节。

- Python3内置的xmlrpc.client模块文档：https://docs.python.org/3/library/xmlrpc.client.html

首先来看blogger.getUsersBlogs这个接口，这个接口需要三个参数，appKey、username和password，经过试验，key可以为空，username和password分别是登录博客园的用户名和密码。接口调用的Python代码很简单，首先通过接口URL获取一个ServerProxy对象，然后在该对象上执行方法即可，如下所示：

```python
import xmlrpc.client

# 其中，接口URL就是MetaWeblog的URL。
bp = xmlrpc.client.ServerProxy(接口URL)
print(bp.blogger.getUsersBlogs('', 用户名, 密码))
'''
类似的调用其他的接口
print(bp.blogger.deletePost())
print(bp.metaWeblog.editPost())
print(bp.metaWeblog.getCategories())
print(bp.metaWeblog.getPost())
print(bp.metaWeblog.getRecentPosts())
print(bp.metaWeblog.newMediaObject())
print(bp.metaWeblog.newPost())
print(bp.wp.newCategory())
调用接口方法需要的参数需要自己点击MetaWeBlog的url去查看
'''

```

# 4、编写的本地博客同步程序
```python
import xmlrpc.client
import os
import time
import re
import json
import logging
import traceback
import win32con
import win32api  # 第三方库
import requests  # 第三方库
from PIL import Image  # 第三方库
from io import BytesIO

"""
需要用到metaWeBlog接口的有以下几个：
blogger.deletePost
metaWeblog.editPost
metaWeblog.getRecentPosts
metaWeblog.newPost
metaWeblog.newMediaObject

"""

metaWeblogUrl = "https://rpc.cnblogs.com/metaweblog/Karl-H"
username = "2443005004@qq.com"
passwd = "2019HUANG520.."
localNotesPath = r"E:\500IT\550notes"


def getblogInfoRecord():
    with open("blogInfoRecord.json", "a+", encoding="utf-8") as f:
        f.seek(0)
        if f.read() == "":
            return {}
        else:
            f.seek(0)
            return json.load(f)


def setblogInfoRecord():
    with open("blogInfoRecord.json", "w", encoding="utf-8") as f:
        json.dump(blogInfoRecord, f, ensure_ascii=False)


def hiddenImagesFolder():
    imagesPathList = []
    for root, dirs, files in os.walk(localNotesPath, True):
        if dirs.count("images"):
            imagesPathList.append(root)

    for path in imagesPathList:
        os.chdir(path)
        win32api.SetFileAttributes(r".\images", win32con.FILE_ATTRIBUTE_HIDDEN)


def getAllBlogs(username, passwd):
    r = blogProxy.metaWeblog.getRecentPosts("", username, passwd, 99999)
    return r


def newPost(user, pwd, data):
    r = blogProxy.metaWeblog.newPost("", user, pwd, data, True)
    return r


def editPost(id, user, pwd, data):
    r = blogProxy.metaWeblog.editPost(id, user, pwd, data, True)
    return r


def deletePost(id, user, pwd):
    r = blogProxy.blogger.deletePost("", id, user, pwd, True)
    return r


def uploadImage(filePath):
    fileData = {
        "type": "image/png",
        "name": "1.png",
    }
    with open(filePath, "rb") as f:
        bits = xmlrpc.client.Binary(f.read())
        fileData["bits"] = bits
    r = blogProxy.metaWeblog.newMediaObject("", username, passwd, fileData)
    return r["url"]


def searchBlog(keyword):
    global blogList
    for blog in blogList:
        if blog["title"] == keyword:
            blogInfo = {
                "title": blog["title"],
                "postid": blog["postid"],
                "url": blog["permalink"],
                "content": blog["description"],
                "publishDate": blog["dateCreated"],
            }
            return blogInfo
    return False


def handleImage(filePath):
    # 判断有没有images文件夹
    imagesFolder = os.path.dirname(filePath) + "\\images\\"
    if not os.path.exists(imagesFolder):
        os.mkdir(imagesFolder)
    with open(filePath, "r", encoding="utf-8") as f:
        content = f.read()
        pattern = "!\[.*?\]\((.+?)\)"
        imageUrls = re.findall(pattern, content)
        # 文件没有图片,直接返回内容
        if len(imageUrls) == 0:
            return content
        # 文件有图片,处理图片,然后重新排序图片,再返回内容,要考虑网络延时报错的情况
        for url in imageUrls:
            # 本地绝对路径
            if os.path.isabs(url):
                if not os.path.isfile(url):
                    logging.error(f"文件  {filePath}  的\n{url}  不存在！")
                    print(f"文件  {filePath}  的\n{url}  不存在！")
                    continue
                src = url
            # 网络路径
            elif re.search("http", url):
                print(url)
                try:
                    r = requests.get(url, headers=headers, timeout=2)
                except:
                    logging.error(f"文件  {filePath}  的\n{url},需手动下载！")
                    print(f"文件  {filePath}  的\n{url}n  ,需手动下载！")
                    continue
                src = BytesIO(r.content)
            # 本地相对路径
            else:
                src = (
                    os.path.dirname(filePath)
                    + "\\images\\"
                    + url.replace("\\", "/").split("/").pop()
                )
            im = Image.open(src)
            # 图片格式GIF或PNGz
            if im.format == "GIF":
                suffix = im.format
            else:
                suffix = "PNG"
            dst = (
                os.path.dirname(filePath)
                + "\\images\\"
                + os.path.basename(filePath)
                + "-"
                # 文件排序数字
                + str(imageUrls.index(url))
                + "."
                + suffix
            )
            im.save(dst)
            newUrl = "images/" + dst.split("\\").pop()
            content = content.replace(url, newUrl)
        with open(filePath, "w", encoding="utf-8") as f:
            f.write(content)
    return content


def handleContent(filePath):
    content = handleImage(filePath)
    RelativePathPattern = "!\[.*?\]\((.+?)\)"
    imgaeUrls = re.findall(RelativePathPattern, content)
    # 文件没有图片,直接返回内容
    if len(imgaeUrls) == 0:
        return content
    for url in imgaeUrls:
        image = url.replace("\\", "/").split("/").pop()
        imgAbsPath = os.path.dirname(filePath) + "\\images\\" + image
        # 过滤失效的url
        if not os.path.isfile(imgAbsPath):
            continue
        newUrl = uploadImage(imgAbsPath)
        content = content.replace(url, newUrl)
    return content


def postBlog(title, filePath):
    response = searchBlog(title)
    # 笔记已发布过了
    if response:
        blogInfo = {
            "title": response["title"],
            "url": response["url"],
            "postid": response["postid"],
        }
        # 笔记修改过
        if (
            title not in blogInfoRecord
            or os.path.getmtime(filePath) != blogInfoRecord[title]
        ):
            print(f"{title}——笔记修改过")
            with open(filePath, "r", encoding="utf-8") as f:
                fileContent = handleContent(filePath)
            postData = {
                "title": title,
                "description": fileContent,
                "categories": ["[Markdown]"],
            }
            postid = response["postid"]
            r = editPost(postid, username, passwd, postData)
            if r:
                time.sleep(1)
                # 更新blogInfoRecord里的信息
                blogInfoRecord[title] = os.path.getmtime(filePath)
                return blogInfo
        # 笔记没修改过
        else:
            print(f"{title}——笔记没修改过")
            return blogInfo
    # 笔记没发布过
    else:
        with open(filePath, "r", encoding="utf-8") as f:
            fileContent = handleContent(filePath)
        postData = {
            "title": title,
            "description": fileContent,
            "categories": ["[Markdown]"],
        }
        try:
            postid = newPost(username, passwd, postData)
        except xmlrpc.client.Fault as err:
            if err.faultString == "Failed":
                logging.error(f"“{filePath}”，发布失败，需要手动发布")
                return False
            # 更新blogInfoRecord里的信息
        blogInfoRecord[title] = os.path.getmtime(filePath)
        blogInfo = {
            "title": title,
            "postid": postid,
            "url": f"www.cnblogs.com/NEGAN-H/p/{postid}.html",
        }
        return blogInfo


def addCategoryTitleLevel(root):
    # 删掉笔记文件夹前面的文件夹路径
    folderName = root.replace(localNotesPath + "\\", "")
    length = len(folderName.split("\\"))
    # markdown添加#标题等级
    global blogDirectory
    blogDirectory += f'{length*"#"} {folderName} \n'


def deleteBlogs():
    global blogList
    cloudBlogTitleList = [blog["title"] for blog in blogList]
    deleteBlogTitleList = []
    # 获取删除博客列表
    for titile in cloudBlogTitleList:
        if titile == "博客目录索引":
            continue
        if titile not in localAllNotesTitle:
            deleteBlogTitleList.append(titile)
    if len(deleteBlogTitleList) == 0:
        return False
    for title in deleteBlogTitleList:
        for blog in blogList:
            if title == blog["title"]:
                try:
                    r = deletePost(blog["postid"], username, passwd)
                except xmlrpc.client.Fault as err:
                    if err.faultString == "! can not be deleted！":
                        logText = f"笔记“ {title} ”无法删除，需手动删除！\n"
                        logging.error(logText)
        if title in blogInfoRecord:
            del title


def start():
    if not os.path.exists(localNotesPath):
        logging.error("笔记路径不存在，请检查！")
        return
    for root, dirs, files in os.walk(localNotesPath, True):
        # 过滤没用的root目录
        if re.search("\.git", root) or root == localNotesPath or len(files) == 0:
            continue
        addCategoryTitleLevel(root)
        for file in files:
            filename = os.path.splitext(file)[0]
            suffix = os.path.splitext(file)[-1]
            filePath = f"{root}\{file}"
            if suffix != ".md":
                localAllImagesAbsPath.append(filePath)
            else:
                localAllNotesTitle.append(filename)
                localAllNotesAbsPath.append(filePath)
                r = postBlog(filename, filePath)
                if not r:
                    continue
                global blogDirectory
                blogDirectory += f"[{r['title']}]({r['url']})\n"


def setblogDirectory():
    if not blogDirectory:
        return False
    postData = {
        "title": "博客目录索引",
        "description": blogDirectory,
        "categories": ["[Markdown]"],
    }
    searchResult = searchBlog("博客目录索引")
    if searchResult:
        r = editPost(searchResult["postid"], username, passwd, postData)
    else:
        r = newPost(username, passwd, postData)
    if r:
        logging.info(f"博客目录索引完成了\n")


def deleteImages():
    global localAllNotesAbsPath
    global localAllImagesAbsPath
    localAllNotesUseImages = []
    for fileAbsPath in localAllNotesAbsPath:
        # print(fileAbsPath)
        f = open(fileAbsPath, "r", encoding="utf-8")
        content = f.read()
        RelativePathPattern = "!\[.*?\]\((.+?)\)"
        imgaeUrls = re.findall(RelativePathPattern, content)
        for url in imgaeUrls:
            image = url.replace("\\", "/").split("/").pop()
            imgAbsPath = os.path.dirname(fileAbsPath) + "\\images\\" + image
            localAllNotesUseImages.append(imgAbsPath)
        f.close()
    for path in localAllImagesAbsPath:
        if path not in localAllNotesUseImages:
            print(f"正在删除图片{path}")
            os.remove(path)


if __name__ == "__main__":
    headers = {
        "user-agent": (
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
            "AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/90.0.4430.72 Safari/537.36 Edg/90.0.818.42"
        )
    }
    # 配置loggin，用于记录日志
    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(message)s",
        filename="blog.log",
        encoding="utf-8",
        level=logging.INFO,
    )
    # 分割线，便于区分日志
    logging.info("\n==================================================\n")
    # 博客目录
    blogDirectory = ""
    # 本地所有笔记标题
    localAllNotesTitle = []
    # 本地所有笔记绝对路径
    localAllNotesAbsPath = []
    # 所有笔记的images文件夹里的图片绝对路径
    localAllImagesAbsPath = []
    # 获取博客信息json文件，用于判断是否需要更新
    blogInfoRecord = getblogInfoRecord()
    try:
        # 获取ServerProxy对象，用于发送请求
        blogProxy = xmlrpc.client.ServerProxy(metaWeblogUrl)
        # 获取全部博客，用于博客搜索
        blogList = getAllBlogs(username, passwd)
        start()
        deleteImages()
        setblogDirectory()
        setblogInfoRecord()
        # 这个必须放最后面，否则会影响blogInfoRecord.json的生成路径
        hiddenImagesFolder()
        logging.info("博客同步成功！！！")
    except xmlrpc.client.Fault as err:
        if (
            err.faultString == "! User does not exist"
            or err.faultString == "User does not exist"
        ):
            logging.error("IP被拉黑了！！！")
        else:
            logging.error(err.faultString)
            print(traceback.format_exc())
        if blogInfoRecord:
            setblogInfoRecord()
            # 这个必须放最后面，否则会影响blogInfoRecord.json的生成路径
            hiddenImagesFolder()

```



-----

参考：
https://www.cnblogs.com/nickchen121/p/11132957.html
https://www.cnblogs.com/xupccc/p/9565337.html
https://my.oschina.net/u/4318872/blog/4255010
https://blog.csdn.net/vir56k/article/details/105136435
https://zhuanlan.zhihu.com/p/73564778
https://blog.csdn.net/shajunxing/article/details/79553472
https://docs.python.org/3/library/xmlrpc.client.html
https://blog.csdn.net/weixin_30645617/article/details/97408199
https://blog.csdn.net/phphot/article/details/1863764